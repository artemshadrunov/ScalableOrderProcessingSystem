# System Design — Итерация 2

```
## Архитектура и обоснование решений

Система состоит из пяти ключевых бизнесовых модулей:

* **Личный кабинет пользователя** (регистрация, адреса, платёжные средства)
* **Обработка заказов** (создание, оплата, подтверждение)
* **Склад** (учёт и резервирование товаров)
* **Доставка** (фулфилмент, трекинг)
* **Платёжная система** (интеграция с внешними провайдерами)

### Инфраструктура: Serverless(AWS)

Serverless выбран за небольшие накладные расходы на DevOps и большие возможности для горизонтального масштабирования. Заказчик prefers solutions that minimize operational complexity.

### Архитектурный стиль: распределённый модульный монолит

Все модули реализуются внутри одного проекта, но по-возможности изолированы логически и структурно через Event Driven подход.

**Почему модульный монолит:**

* Дешевле в разработке, поддержке, расширении
* Внутренние границы модулей чёткие, с низкой связанностью через события
* Можно со временем выносить отдельные модули в микросервисы при необходимости

**Почему не микросервисы:**

Микросервисы требуют больше человеко-часов: отдельные команды, деплой, CI/CD, внешние брокеры, накладные расходы на DevOps. Это повышает входной порог и делает систему дороже в сопровождении. Заказчик prefers solutions that minimize operational complexity.

**Вычисления:** AWS Lambda

* Снижает накладные расходы на DevOps
* Хороший потенциал масштабирования
* Оплата по факту использования, есть возможность купить провиженинг

**Базы данных:** гибрид через CAP-подход

* **DynamoDB** — для зон, где eventual consistency допустима (личный кабинет, доставка)
* **Aurora** — для заказов, склада и платежей, где важна строгая консистентность

**Хранилище файлов:** AWS S3 + CloudFront

* **S3** — для хранения изображений товаров и других статических файлов
* **CloudFront** — CDN для быстрой доставки изображений пользователям


**Кэш:** ElastiCache (Redis)

* Быстрый доступ к часто используемым данным
* Снижает нагрузку на основные базы данных

**Обмен событиями:** EventBridge + DLQ

* EventBridge — маршрутизация бизнес-событий между модулями
* DLQ (Dead Letter Queue) — надёжная доставка, хранение необработанных событий для повторной обработки

**Плановые задачи:** EventBridge Schedule

* Запуск фоновых job’ов по расписанию (например, очистка просроченных заказов)
* Без отдельного сервера — полностью serverless

**Платежи:** Stripe

* Готовое и безопасное решение для приёма онлайн-платежей
* Поддержка карт, Apple Pay, Google Pay, возвратов и подписок

**Нотификации:** TBD

* Решение для отправки email/SMS/push-уведомлений будет выбрано на следующих этапах

### Деплой и Infrastructure as Code: AWS CDK

Для управления инфраструктурой и деплоя используется **AWS CDK (Cloud Development Kit)**.

**Почему AWS CDK:**

* **TypeScript/JavaScript** — знакомый язык для разработчиков, строгая типизация
* **Повторное использование** — создание переиспользуемых компонентов инфраструктуры
* **Локальное тестирование** — возможность тестировать инфраструктуру локально
* **Автоматический деплой** — интеграция с CI/CD для автоматического обновления инфраструктуры
* **Версионирование** — инфраструктура как код в Git репозитории

**Компоненты инфраструктуры:**

* **Database Stack** — создание Aurora кластера, DynamoDB таблиц, ElastiCache
* **API Stack** — API Gateway, Lambda функции, IAM роли
* **Storage Stack** — S3 bucket, CloudFront distribution
* **Events Stack** — EventBridge bus, правила, Dead Letter Queue
* **Monitoring Stack** — CloudWatch dashboards, алерты, логирование

**CI/CD интеграция:**

* Автоматический деплой при merge в main ветку
* Тестирование инфраструктуры перед деплоем
* Blue-green деплой для критичных компонентов
* Автоматическое создание staging окружения для feature веток 

### Внутренняя коммуникация между модулями

В системе используется event-driven подход для внутренней коммуникации между модулями: ключевые бизнес-события (например, изменение статуса заказа) публикуются в EventBridge, а обработчики событий реализованы на AWS Lambda. Это позволяет модулям реагировать на изменения асинхронно, без жёсткой связности между ними.

**Почему не выбраны прямые внутренние вызовы:**
- Прямые вызовы между модулями (например, через HTTP или SDK) приводят к сильной связности: сервисы должны знать друг о друге, их API и контракты, что усложняет масштабирование и эволюцию системы.
- Event-driven архитектура снижает связность, упрощает добавление новых подписчиков (например, аналитика, уведомления), облегчает выделение модулей в отдельные сервисы и может повысить отказоустойчивость(https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-rule-retry-policy.html , https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-rule-dlq.html).
- В AWS накладные расходы на EventBridge и Lambda минимальны, а гибкость и масштабируемость системы значительно возрастают.

### Скейлинг

API Gateway + Lambda ≈ 10 000 RPS (при 1 000 concurrency и 100 мс среднем ответе). Сразу подать quota-request до 1 000 concurrency, позже можно еще повысить.

DynamoDB ≈ 40 000 RPS чтения и 40 000 RPS записи на таблицу. Шардирование ключей чтобы избежать hot-partition.

Aurora ~ 2 000–5 000 QPS на r5.large/xlarge, можно использовать read реплики, чтобы снизить нагрузку.

---

# Детали реализации

**Создание заказа + Резерв товаров** — одна атомарная транзакция с локом на изменение конкретных SKU, чтобы избежать race conditions.

**Снятие резерва для просроченных заказов:** отдельная лямбда по расписанию ищет просроченные заказы и пачками удаляет их, снимая резерв с товаров. Если количество просроченных заказов начинает быстро расти и “хвост” не успевает обрабатываться, увеличиваем размер пачки и/или частоту запусков Lambda, а при необходимости переходим на параллельную обработку отдельным сервисом. Настраиваем мониторинг и алерты по размеру “хвоста” для своевременного реагирования.

---

# Безопасность
- HTTPS для всех API вызовов
- Валидация данных на клиенте и сервере
- Аутентификации через JWT токены
- api-key для ограничения использования API третьими лицами
- Rate limiting, чтобы защититься от DDoS и злоупотреблений.

---

### Клиентская часть

Система включает три типа клиентских приложений, каждое оптимизировано под свои задачи:

#### 1. Маркетплейс
**Целевая аудитория:** Покупатели  
**Технологии:** React/Next.js, мобильное приложение (React Native/Flutter)

**Функциональность:**
- Регистрация и авторизация пользователей
- Просмотр каталога товаров с фильтрацией и поиском
- Отображение изображений товаров (хранятся в S3, доставляются через CloudFront)
- Управление корзиной (добавление, удаление, изменение количества)
- Оформление заказов с выбором адреса доставки и способа оплаты
- Отслеживание статуса заказов и доставки
- Управление профилем (адреса, платёжные методы)
- История заказов

#### 2. Складской клиент (Warehouse Portal)
**Целевая аудитория:** Работники склада  
**Технологии:** React/Next.js, PWA для планшетов

**Функциональность:**
- Управление списком товаров и остатками (приёмка, корректировки)
- Управление заказами(отмена в случае форс-мажора)

#### 3. Клиент доставки (Delivery Portal)
**Целевая аудитория:** Курьеры и менеджеры доставки  
**Технологии:** React Native/Flutter для мобильных приложений

**Функциональность:**
- Просмотр списка заказов для доставки
- Обновление статуса доставки
- Уведомления о новых заказах и изменениях статуса

Часть данных можно кэшировать на клиентской стороне чтобы экономить на трафике.