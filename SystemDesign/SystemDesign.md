# System Design — Итерация 2

```
## Архитектура и обоснование решений

Система состоит из пяти ключевых бизнесовых модулей:

* **Личный кабинет пользователя** (регистрация, адреса, платёжные средства)
* **Обработка заказов** (создание, оплата, подтверждение)
* **Склад** (учёт и резервирование товаров)
* **Доставка** (фулфилмент, трекинг)
* **Платёжная система** (интеграция с внешними провайдерами)

### Архитектурный стиль: распределённый модульный монолит

Все модули реализуются внутри одного проекта, но по возможности изолированы логически и структурно.

**Почему модульный монолит:**

* Дешевле в разработке, поддержке, расширении
* Внутренние границы модулей чёткие, с низкой связанностью через события
* Можно со временем выносить отдельные модули в микросервисы при необходимости

**Почему не микросервисы:**

Микросервисы требуют больше человеко-часов: отдельные команды, деплой, CI/CD, внешние брокеры, накладные расходы на DevOps. Это повышает входной порог и делает систему дороже в сопровождении. Заказчик prefers solutions that minimize operational complexity.

### Инфраструктура: Serverless и AWS

Система масштабируется горизонтально за счёт Serverless. Внутренняя событийная модель снижает связанность между модулями, что позволяет со временем при необходимости выносить их в отдельные микросервисы.

**Вычисления:** AWS Lambda

* Снижает накладные расходы на DevOps
* Хороший потенциал масштабирования
* Оплата по факту использования, есть возможность купить провиженинг

**Базы данных:** гибрид через CAP-подход

* **DynamoDB** — для зон, где eventual consistency допустима (личный кабинет, доставка)
* **Aurora** — для заказов, склада и платежей, где важна строгая консистентность

**Хранилище файлов:** AWS S3 + CloudFront

* **S3** — для хранения изображений товаров и других статических файлов
* **CloudFront** — CDN для быстрой доставки изображений пользователям 

### Внутренняя коммуникация между модулями

В системе используется event-driven подход для внутренней коммуникации между модулями: ключевые бизнес-события (например, изменение статуса заказа) публикуются в EventBridge, а обработчики событий реализованы на AWS Lambda. Это позволяет модулям реагировать на изменения асинхронно, без жёсткой связности между ними.

**Почему не выбраны прямые внутренние вызовы:**
- Прямые вызовы между модулями (например, через HTTP или SDK) приводят к сильной связности: сервисы должны знать друг о друге, их API и контракты, что усложняет масштабирование и эволюцию системы.
- Event-driven архитектура снижает связность, упрощает добавление новых подписчиков (например, аналитика, уведомления), облегчает выделение модулей в отдельные сервисы и может повысить отказоустойчивость(https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-rule-retry-policy.html , https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-rule-dlq.html).
- В AWS накладные расходы на EventBridge и Lambda минимальны, а гибкость и масштабируемость системы значительно возрастают.

### Скейлинг

API Gateway + Lambda ≈ 10 000 RPS (при 1 000 concurrency и 100 мс среднем ответе). Сразу подать quota-request до 1 000 concurrency, позже можно еще повысить.

DynamoDB ≈ 40 000 RPS чтения и 40 000 RPS записи на таблицу. Шардирование ключей чтобы избежать hot-partition.

Aurora ~ 2 000–5 000 QPS на r5.large/xlarge, можно использовать read реплики, чтобы снизить нагрузку.

---

# Детали реализации

### Cart + Stock — одна атомарная транзакция

```sql
BEGIN;
SELECT quantity, reserved
  FROM stock
 WHERE sku = :sku
   FOR UPDATE;         -- блокируем строку

IF quantity - reserved < :need THEN ROLLBACK;

UPDATE stock
   SET reserved = reserved + :need
 WHERE sku = :sku;

INSERT INTO stock_reserve(reserve_id, sku, qty, cart_id, expires_at)
VALUES(:rid, :sku, :need, :cart, now() + interval '1 hour');

INSERT INTO cart_items(cart_id, sku, qty, price) VALUES (...);
COMMIT;
```

*Гонка* решается row‑lock’ом, а `stock_reserve` хранит TTL и «чьи именно» штуки зарезервированы.

### TTL‑работа

Scheduled Lambda с помощью EventBridge каждые N секунд:

- Ищем заказы, у которых истек TTL или в статусе cancelled
- Группируем товары по SKU, апдейтим количество

### Клиентская часть

**Общие принципы:**
- Аутентификации через JWT токены
- Кэширование данных для улучшения производительности

**Безопасность:**
- HTTPS для всех API вызовов
- Валидация данных на клиенте и сервере

Система включает три типа клиентских приложений, каждое оптимизировано под свои задачи:

#### 1. Маркетплейс
**Целевая аудитория:** Покупатели  
**Технологии:** React/Next.js, мобильное приложение (React Native/Flutter)

**Функциональность:**
- Регистрация и авторизация пользователей
- Просмотр каталога товаров с фильтрацией и поиском
- Отображение изображений товаров (хранятся в S3, доставляются через CloudFront)
- Управление корзиной (добавление, удаление, изменение количества)
- Оформление заказов с выбором адреса доставки и способа оплаты
- Отслеживание статуса заказов и доставки
- Управление профилем (адреса, платёжные методы)
- История заказов

#### 2. Складской клиент (Warehouse Portal)
**Целевая аудитория:** Работники склада  
**Технологии:** React/Next.js, PWA для планшетов

**Функциональность:**
- Управление списком товаров и остатками (приёмка, корректировки)
- Управление заказами(отмена в случае форс-мажора)

#### 3. Клиент доставки (Delivery Portal)
**Целевая аудитория:** Курьеры и менеджеры доставки  
**Технологии:** React Native/Flutter для мобильных приложений

**Функциональность:**
- Просмотр списка заказов для доставки
- Обновление статуса доставки
- Уведомления о новых заказах и изменениях статуса
